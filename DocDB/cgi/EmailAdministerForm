#! /usr/bin/env perl
#
#        Name: EmailAdministerForm
# Description: This script provides a form to administer users receiving
#              e-mail notifications and shows the complete list of who is
#              receiving what.
#
#      Author: Eric Vaandering (ewv@fnal.gov)
#    Modified: 
#

# Copyright 2001-2005 Eric Vaandering, Lynn Garren, Adam Bryant

#    This file is part of DocDB.

#    DocDB is free software; you can redistribute it and/or modify
#    it under the terms of version 2 of the GNU General Public License 
#    as published by the Free Software Foundation.

#    DocDB is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.

#    You should have received a copy of the GNU General Public License
#    along with DocDB; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

use CGI;                                                                                      
use DBI;

require "DocDBGlobals.pm";
require "Scripts.pm";
require "ResponseElements.pm";
require "Security.pm";
require "HTMLUtilities.pm";
require "AdministerElements.pm";
require "SecurityHTML.pm";

require "MailNotification.pm";
require "Sorts.pm";
require "SecuritySQL.pm";
require "NotificationSQL.pm";

$query = new CGI;  # Global for subroutines
$dbh   = DBI -> connect('DBI:mysql:'.$db_name.':'.$db_host,$db_rouser,$db_ropass);

GetSecurityGroups();

print $query->header;
DocDBHeader("User Administration","",-scripts => ["PopUps","PersonalAccountAdminDisable"]); 

@ErrorStack = ();
@WarnStack  = ();

unless (CanAdminister()) {
  push @ErrorStack,"You are not allowed to access administrative functions.";
}

EndPage();

print "<p><b>This form allows you to administer personal accounts.</b></p>\n"; 

print "<p>Since users can modify their own data and create their own accounts,
       the only functions you can perform here are to delete a user";
unless ($UserValidation eq "certificate") {
  print ", reset the user's password,"; 
}
print " and change which groups the user belongs to. If any groups are selected or 
       \"Clear Groups\" is selected, the list of groups the user belongs to will be cleared and
       set to the selected groups. The full list of users, their groups, preferences, and which
       notifications they recieve  are shown below for your reference.</p>\n";

### Email User Modification

print $query -> start_multipart_form('POST',"$EmailAdminister",
                                     "id=\"peraccount\" name=\"peraccount\"");
print "<table class=\"HighPaddedTable\">\n";
print "<tr>\n";

print "<td colspan=\"2\">\n";
 AdministerActions(-form => "peraccount");
print "</td>\n";

print "</tr>\n";

print "<tr>\n";

print "<td>\n"; 
 EmailUserSelect(-disabled => $TRUE);
print "</td>\n";  

print "<td>\n";   
if ($UserValidation eq "certificate") {
  print "&nbsp;\n";
} else { 
  print FormElementTitle(-helplink => "resetpassword", -helptext => "New Password"); 
  print $query -> textfield (-name => 'resetpw', -size => 20, -maxlength => 20, -disabled);
}
print "</td>\n";
print "<td rowspan=\"5\">\n"; 
SecurityScroll(-helplink => 'usergroups', -helptext => 'User\'s Groups', 
               -name     => 'usergroups', -disabled => $TRUE, -multiple => $TRUE); 
print "</td>\n";  
print "</tr>\n";

print "<tr><td>\n";
print $query -> checkbox(-name  => "verifyuser", -label => 'Verify User');
print "</td></tr>\n";
print "<tr><td>\n";
print $query -> checkbox(-name  => "usersign", -label => 'User Can Sign Docs');
print "</td></tr>\n";
print "<tr><td>\n";
print $query -> checkbox(-name  => "clearuser", -label => 'Clear Verify and Sign');
print "</td></tr>\n";
print "<tr><td>\n";
print $query -> checkbox(-name  => "cleargroups", -label => 'Clear User\'s Groups');
print "</td></tr>\n";

print "<tr>\n";
print "<td colspan=\"3\">\n";
AdministratorPassword();
print "&nbsp;";
print $query -> submit(-value => "Modify Personal Account");
print "</td>\n";
print "</tr>\n";

print "</table>\n";
print $query -> end_multipart_form;

print "<p>\n";
print "<b>The personal accounts and when they receive e-mail are shown below:</b></p>\n";
print "<hr/>\n";

### Display of existing groups

my @EmailUserIDs = sort EmailUserIDsByName GetEmailUserIDs();

print "<table class=\"LowPaddedTable\">\n";
foreach my $EmailUserID (@EmailUserIDs) {
  FetchEmailUser($EmailUserID);  
  print "<tr>\n";
  print "<td>\n";

  print "<table class=\"LowPaddedTable LeftHeader\">\n";
  print "<tr>\n";
  print "<th>Username:</th><td>$EmailUser{$EmailUserID}{Username}</td>\n"; 
  print "</tr><tr>\n";
  print "<th>Name:</th><td>$EmailUser{$EmailUserID}{Name}</td>\n"; 
  print "";
  print "</tr><tr>\n";
  print "<th>E-mail:</th><td>$EmailUser{$EmailUserID}{EmailAddress}</td>\n"; 
  print "</tr><tr>\n";
  print "<th>Verified:</th>";
  print "<td>".("No","Yes")[$EmailUser{$EmailUserID}{Verified}]."</td>\n"; 
  print "</tr><tr>\n";
  print "<th>HTML:</th>";
  print "<td>".("No","Yes")[$EmailUser{$EmailUserID}{PreferHTML}]."</td>\n"; 
  print "</tr><tr>\n";
  print "<th>Can Sign:</th>";
  print "<td>".("No","Yes")[$EmailUser{$EmailUserID}{CanSign}]."</td>\n"; 
  print "</tr><tr>\n";
  
  # Groups user belongs (or wants to belong to)
  
  print "<th>Groups:</th>";
  print "<td><ul>\n"; 
  my @UserGroupIDs = FetchUserGroupIDs($EmailUserID);
  foreach my $UserGroupID (@UserGroupIDs) {
    FetchSecurityGroup($UserGroupID);
    print "<li>$SecurityGroups{$UserGroupID}{NAME}</li>";
  }   
  print "</ul></td>\n";
  print "</tr>\n";
  print "</table>\n";
  print "</td>\n";

  print "<td>\n";
  DisplayNotification($EmailUserID,"Immediate");
  print "</td>\n";

  print "<td>\n";
  DisplayNotification($EmailUserID,"Daily");
  print "</td>\n";

  print "<td>\n";
  DisplayNotification($EmailUserID,"Weekly");
  print "</td>\n"; 

  print "</tr>\n";
  print "<tr><td colspan=\"5\"><hr width=\"95%\" /></td></tr>\n";
} 
print "</table>\n";

### List of groups with associated names

my @SecurityGroups = sort keys %SecurityIDs;

foreach my $SecurityGroup (@SecurityGroups) {
  my @EmailUserIDs = sort EmailUserIDsByName FetchEmailUSerIDsBySecurityGroup($SecurityIDs{$SecurityGroup});
  if (@EmailUserIDs) {
    print "<strong>$SecurityGroup has these members:</strong>\n<ul>\n";
    foreach my $EmailUserID (@EmailUserIDs) {
      if ($EmailUser{$EmailUserID}{Name}) { 
        print "<li>$EmailUser{$EmailUserID}{Name} ($EmailUser{$EmailUserID}{Username}, $EmailUser{$EmailUserID}{EmailAddress})</li>\n";
      }
    }
    print "</ul>\n";
  }     
}

print "<p/><hr/><p/>\n";

DocDBNavBar();
DocDBFooter($DBWebMasterEmail,$DBWebMasterName);
