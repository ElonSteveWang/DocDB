#! /usr/bin/env perl
#
#        Name: EmailAdministerForm
# Description: This script provides a form to administer users receiving
#              e-mail notifications and shows the complete list of who is
#              receiving what.
#
#      Author: Eric Vaandering (ewv@fnal.gov)
#    Modified: 
#

# Copyright 2001-2006 Eric Vaandering, Lynn Garren, Adam Bryant

#    This file is part of DocDB.

#    DocDB is free software; you can redistribute it and/or modify
#    it under the terms of version 2 of the GNU General Public License 
#    as published by the Free Software Foundation.

#    DocDB is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.

#    You should have received a copy of the GNU General Public License
#    along with DocDB; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

use CGI qw(-nosticky);                                                                                      
use DBI;

require "DocDBGlobals.pm";
require "Scripts.pm";
require "ResponseElements.pm";
require "Security.pm";
require "HTMLUtilities.pm";
require "AdministerElements.pm";
require "EmailUserHTML.pm";
require "SecurityHTML.pm";

require "MailNotification.pm";
require "Sorts.pm";
require "SecuritySQL.pm";
require "NotificationSQL.pm";

$query = new CGI;  # Global for subroutines
$dbh   = DBI -> connect('DBI:mysql:'.$db_name.':'.$db_host,$db_rouser,$db_ropass);

%params = $query -> Vars;

my $EmailUserID  = $params{emailuserid} || 0;

GetSecurityGroups();

print $query->header;
DocDBHeader("User Administration","",-scripts => ["PopUps","PersonalAccountAdminDisable"]); 

@ErrorStack = ();
@WarnStack  = ();

unless (CanAdminister()) {
  push @ErrorStack,"You are not allowed to access administrative functions.";
}

EndPage();

print "<p><b>This form allows you to administer personal accounts.</b></p>\n"; 

print "<p>Since users can modify their own data and create their own accounts,
       the only functions you can perform here are to delete a user";
unless ($UserValidation eq "certificate") {
  print ", reset the user's password,"; 
}
print " and change which groups the user belongs to. If  \"Clear Groups\" is
       selected, the list of groups the user belongs to will be cleared and set
       to the selected groups (if any). Use this option if any of the groups a user
       currently belongs to are incorrect. The full list of users, their
       groups, preferences, and which notifications they recieve are shown
       below for your reference.</p>\n";

### Email User Modification

print $query -> start_multipart_form('POST',"$EmailAdminister",
                                     "id=\"peraccount\" name=\"peraccount\"");
print "<table class=\"MedPaddedTable\">\n";
print "<tr>\n";

print "<td colspan=\"3\">\n";
 AdministerActions(-form => "peraccount");
print "</td>\n";

print "</tr>\n";

print "<tr>\n";

print "<td>\n"; 
 EmailUserSelect(-disabled => $TRUE);
print "</td>\n";  

print "<td>\n";   
if ($UserValidation eq "certificate") {
  print "&nbsp;\n";
} else { 
  print FormElementTitle(-helplink => "resetpassword", -helptext => "New Password"); 
  print $query -> textfield (-name => 'resetpw', -size => 20, -maxlength => 20, -disabled => "disabled");
}
print "</td>\n";
print "<td>\n"; 
SecurityScroll(-helplink => 'usergroups', -helptext => 'User\'s Groups', 
               -name     => 'usergroups', -disabled => $TRUE, -multiple => $TRUE); 
print "</td>\n";  
print "</tr>\n";

print "<tr><td colspan=\"3\">\n";
print $query -> checkbox(-name  => "verifyuser", -label => 'Verify User');
print "</td></tr>\n";
print "<tr><td colspan=\"3\">\n";
print $query -> checkbox(-name  => "usersign", -label => 'User Can Sign Docs');
print "</td></tr>\n";
print "<tr><td colspan=\"3\">\n";
print $query -> checkbox(-name  => "clearuser", -label => 'Clear Verify and Sign');
print "</td></tr>\n";
print "<tr><td colspan=\"3\">\n";
print $query -> checkbox(-name  => "cleargroups", -label => 'Clear User\'s Groups');
print "</td></tr>\n";

print "<tr>\n";
print "<td colspan=\"3\">\n";
AdministratorPassword();
print "&nbsp;";
print $query -> submit(-value => "Modify Personal Account");
print "</td>\n";
print "</tr>\n";

print "</table>\n";
print $query -> end_multipart_form;

print "<p>\n";
print "<b>The personal accounts and when they receive e-mail are shown below:</b></p>\n";
print "<hr/>\n";

### Display of existing groups

my @EmailUserIDs = sort EmailUserIDsByName GetEmailUserIDs();

print "<table class=\"LowPaddedTable AlternatingTable\">\n";
print "<tr><th>Username</th><th>Name</th><th>Verified?</th><th>Groups</th><th>Notifications</th></tr>\n";
my $Row = 0;
foreach my $EmailUserID (@EmailUserIDs) {
  ++$Row;
  my $RowClass = ("Odd","Even")[$Row % 2];

  print '<tr class="$RowClass">',"\n";
  print "<td>$EmailUser{$EmailUserID}{Username}</td>\n"; 
  print "<td>$EmailUser{$EmailUserID}{Name}</td>\n"; 
  print "<td>".("No","Yes")[$EmailUser{$EmailUserID}{Verified}]."</td>\n"; 
  print "</tr>\n";
} 
print "</table>\n";

### List of groups with associated names

my @SecurityGroups = sort keys %SecurityIDs;

foreach my $SecurityGroup (@SecurityGroups) {
  my @EmailUserIDs = sort EmailUserIDsByName FetchEmailUserIDsBySecurityGroup($SecurityIDs{$SecurityGroup});
  if (@EmailUserIDs) {
    print "<p><strong>$SecurityGroup has these members:</strong></p>\n<ul>\n";
    foreach my $EmailUserID (@EmailUserIDs) {
      if ($EmailUser{$EmailUserID}{Name}) { 
        print "<li>$EmailUser{$EmailUserID}{Name} ($EmailUser{$EmailUserID}{Username}, $EmailUser{$EmailUserID}{EmailAddress})</li>\n";
      } else {
        print "<li>Unknown</li>\n";
      }  
    }
    print "</ul>\n";
  }     
}

print "<p/><hr/><p/>\n";

DocDBNavBar();
DocDBFooter($DBWebMasterEmail,$DBWebMasterName);
